<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>StagePad Remote</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: #0d0f14;
      color: #e2e8f0;
      padding: 0;
    }
    body {
      padding: 16px;
    }
    body.in-stagepad {
      padding: 0;
    }
    .card {
      background: #11161f;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .card.full-bleed {
      padding-left: 8px;
      padding-right: 8px;
    }
    .card.performance-card {
      padding: 0;
      border-radius: 0;
      border-left: 0;
      border-right: 0;
    }
    #stagepad-view {
      width: 100%;
      padding: 0 0 16px;
    }
    .performance-header {
      padding: 10px 0 6px;
    }
    .card.compact {
      padding: 10px 12px;
      margin-bottom: 8px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    .status {
      font-size: 13px;
      color: #9fb2c8;
    }
    .projects-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }
    .btn {
      border: none;
      border-radius: 12px;
      padding: 12px;
      font-size: 14px;
      font-weight: 600;
      background: #1c222b;
      color: #e2e8f0;
      cursor: pointer;
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .btn.is-active {
      outline: 2px solid rgba(0, 255, 166, 0.7);
      box-shadow: 0 0 16px rgba(0, 255, 166, 0.35);
    }
    .tabs {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin: 0 0 8px;
      position: sticky;
      top: 0;
      z-index: 20;
      background: #0d0f14;
      padding: 4px 0 6px;
    }
    .tab {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      font-weight: 600;
      background: rgba(15, 23, 42, 0.6);
      color: #cbd5e1;
      cursor: pointer;
    }
    .tab.is-active {
      background: linear-gradient(135deg, #2ecc71, #00ffa6);
      color: #0d0f14;
      border-color: transparent;
    }
    .toolbar {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 10px;
    }
    .toolbar.projects-toolbar {
      margin-bottom: 8px;
    }
    .toolbar-btn {
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.08);
      color: #e2e8f0;
    }
    .toolbar-btn:hover {
      background: rgba(0, 255, 166, 0.2);
      color: #00ffa6;
    }
    .mixer-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .mixer-item {
      background: rgba(8, 12, 20, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 14px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .mixer-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .mixer-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.2);
      box-shadow: none;
      transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }
    .mixer-dot.is-active {
      background: #18ffb0;
      box-shadow: 0 0 10px rgba(24, 255, 176, 0.9);
      transform: scale(1.1);
    }
    .mixer-item h4 {
      margin: 0;
      font-size: 13px;
      color: #e2e8f0;
    }
    .mixer-item input[type="range"] {
      width: 100%;
    }
    .mixer-value {
      font-size: 12px;
      color: #9fb2c8;
      text-align: right;
    }
    .stage-grid {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 6px;
      display: grid;
      grid-template-columns: repeat(var(--grid-cols, 1), minmax(0, 1fr));
      grid-template-rows: repeat(var(--grid-rows, 1), minmax(0, 1fr));
      gap: 10px;
      min-height: 120px;
      width: 100%;
      max-width: none;
    }
    .performance-split {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    body.split-mode .split-top {
      max-height: 180px;
      overflow: hidden;
    }
    body.split-mode .split-top .stage-grid {
      max-height: 180px;
      overflow: hidden;
    }
    body.split-mode .split-top .stage-cell {
      min-height: 48px;
    }
    body.split-mode .split-top .stage-cell__btn {
      padding: 6px;
      gap: 4px;
    }
    body.split-mode .split-bottom .stage-cell {
      min-height: 56px;
    }
    body.split-mode .split-bottom .stage-cell__btn {
      padding: 8px;
      gap: 4px;
    }
    body.split-mode .split-bottom {
      max-height: 60vh;
      overflow-y: auto;
    }
    .stage-cell {
      background: rgba(0, 0, 0, 0.25);
      border: 1px dashed rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      min-height: 64px;
    }
    .stage-cell__btn {
      width: 100%;
      height: 100%;
      border: 1px solid rgba(0, 255, 166, 0.25);
      border-radius: 10px;
      background: linear-gradient(145deg, rgba(0, 255, 166, 0.1), rgba(0, 0, 0, 0.2));
      color: #d1d5db;
      padding: 10px;
      display: flex;
      align-items: center;
      flex-direction: column;
      gap: 6px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: transform 0.15s, box-shadow 0.2s, border-color 0.2s;
      justify-content: center;
      --btn-color: #00ffa6;
    }
    .stage-label {
      font-weight: 700;
      font-size: 14px;
      text-align: center;
      width: 100%;
    }
    .stage-progress {
      position: absolute;
      left: 0;
      bottom: 0;
      height: 8px;
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }
    .stage-progress__bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(135deg, #00d5ff, #00ffa6);
      transition: width 0.1s linear;
    }
    .stage-cell__btn.stage--playing {
      box-shadow: 0 0 22px rgba(0, 255, 166, 0.55), 0 0 0 2px rgba(0, 255, 166, 0.45);
      border-color: rgba(0, 255, 166, 0.65);
      transform: translateY(-2px) scale(1.01);
      position: relative;
    }
    .stage-cell__btn.stage--playing::before {
      content: "";
      position: absolute;
      inset: -2px;
      z-index: -1;
      border-radius: 12px;
      filter: blur(8px);
      background: linear-gradient(
        45deg,
        var(--btn-color, #00ffa6),
        #48ff00,
        #00ffd5,
        #002bff,
        #7a00ff,
        #ff00c8,
        var(--btn-color, #00ffa6)
      );
      background-size: 400% 400%;
      animation: glowing 10s linear infinite;
      opacity: 0.9;
    }
    .stage-cell__btn.stage--used {
      background: linear-gradient(145deg, rgba(20, 24, 32, 0.85), rgba(12, 14, 20, 0.9));
      border-color: rgba(255, 255, 255, 0.08);
      color: #9ca3af;
      filter: grayscale(1) brightness(0.6);
    }
    .stage-cell__btn.stage--used .stage-label {
      color: #8b8b8b;
    }
    .stage-cell__btn.stage--used.stage--playing {
      filter: none;
      background: linear-gradient(145deg, var(--btn-color, #00ffa6), rgba(0, 0, 0, 0.25));
      border-color: rgba(0, 255, 166, 0.25);
      color: #d1d5db;
    }
    .stage-cell__btn.stage--used.stage--playing .stage-label {
      color: #ffffff;
    }
    @keyframes glowing {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 255, 166, 0.12);
      color: #00ffa6;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hint {
      font-size: 12px;
      color: #9fb2c8;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div class="card compact" id="status-card">
    <div class="status" id="conn-status">Подключение...</div>
    <div class="hint" id="conn-hint"></div>
  </div>

  <div class="card" id="modules-view">
    <div class="pill">Модули</div>
    <div class="projects-grid" id="modules-list"></div>
    <div class="hint">Выберите модуль для управления.</div>
  </div>

  <div id="stagepad-view" hidden>
    <div class="tabs">
      <button class="tab is-active" type="button" data-tab="projects">Проекты</button>
      <button class="tab" type="button" data-tab="performance">Перфоманс</button>
      <button class="tab" type="button" data-tab="mixer">Микшер</button>
    </div>

    <div class="card" data-panel="projects">
      <div class="toolbar projects-toolbar">
        <button class="toolbar-btn" id="split-toggle" type="button">Сплит: выкл</button>
      </div>
      <div class="projects-grid" id="projects-list"></div>
      <div class="hint">Нажмите проект, чтобы запустить перфоманс.</div>
    </div>

    <div class="card performance-card" data-panel="performance">
      <div class="performance-header">
        <div class="toolbar">
          <button class="toolbar-btn" id="reset-used-btn" type="button">Сбросить использованные</button>
        </div>
      </div>
      <div class="performance-split" id="performance-split">
        <div class="split-top" id="split-top">
          <div class="stage-grid" id="buttons-list"></div>
          <div class="hint" id="buttons-hint">Кнопки появятся после запуска проекта.</div>
        </div>
        <div class="split-bottom" id="split-bottom" hidden>
          <div class="stage-grid" id="buttons-list-bottom"></div>
          <div class="hint" id="buttons-hint-bottom">Выберите второй проект для сплита.</div>
        </div>
      </div>
    </div>

    <div class="card" data-panel="mixer">
      <div class="mixer-list" id="mixer-list"></div>
      <div class="hint" id="mixer-hint">Фейдеры появятся после запуска проекта.</div>
    </div>
  </div>

  <script>
    const statusCard = document.getElementById("status-card");
    const statusEl = document.getElementById("conn-status");
    const hintEl = document.getElementById("conn-hint");
    const modulesView = document.getElementById("modules-view");
    const stagepadView = document.getElementById("stagepad-view");
    const modulesEl = document.getElementById("modules-list");
    const tabButtons = Array.from(document.querySelectorAll("[data-tab]"));
    const panels = Array.from(document.querySelectorAll("[data-panel]"));
    const projectsEl = document.getElementById("projects-list");
    const stageGridEl = document.getElementById("buttons-list");
    const stageGridBottomEl = document.getElementById("buttons-list-bottom");
    const buttonsHintEl = document.getElementById("buttons-hint");
    const buttonsHintBottomEl = document.getElementById("buttons-hint-bottom");
    const resetUsedBtn = document.getElementById("reset-used-btn");
    const splitToggleBtn = document.getElementById("split-toggle");
    const splitBottomEl = document.getElementById("split-bottom");
    const mixerListEl = document.getElementById("mixer-list");
    const mixerHintEl = document.getElementById("mixer-hint");
    let ws = null;
    let activeProjectId = "";
    let lockedProjectId = "";
    let gridState = { rows: 1, cols: 1 };
    let lastPerfState = null;
    const perfStates = new Map();
    let splitMode = false;
    let splitTopProjectId = "";
    let splitBottomProjectId = "";
    let lastProjects = [];
    let mixerDragging = false;
    let mixerDraggingIndex = null;

    let statusTimer = null;
    const showStatus = (text, hint, { autoHide = false } = {}) => {
      statusEl.textContent = text || "";
      hintEl.textContent = hint || "";
      statusCard.hidden = false;
      if (statusTimer) {
        clearTimeout(statusTimer);
        statusTimer = null;
      }
      if (autoHide) {
        statusTimer = setTimeout(() => {
          statusCard.hidden = true;
        }, 2000);
      }
    };

    const send = (payload) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(payload));
      }
    };

    if (splitToggleBtn) {
      splitToggleBtn.textContent = "Сплит: выкл";
    }

    const applyAlphaToHex = (hex, alpha) => {
      const safe = String(hex || "").trim();
      const match = safe.match(/^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/);
      if (!match) return `rgba(0,255,166,${alpha})`;
      let value = match[1];
      if (value.length === 3) {
        value = value
          .split("")
          .map((c) => c + c)
          .join("");
      }
      const r = parseInt(value.slice(0, 2), 16);
      const g = parseInt(value.slice(2, 4), 16);
      const b = parseInt(value.slice(4, 6), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const MIN_DB = -60;
    const MAX_DB = 0;
    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    const sliderToGain = (value) => {
      const v = clamp(Number(value) || 0, 0, 1);
      const db = MIN_DB + (MAX_DB - MIN_DB) * v;
      return Math.pow(10, db / 20);
    };
    const gainToSlider = (gain) => {
      const g = clamp(Number(gain) || 0, 0.000001, 1);
      const db = 20 * Math.log10(g);
      return clamp((db - MIN_DB) / (MAX_DB - MIN_DB), 0, 1);
    };
    const formatDb = (value) => {
      const v = clamp(Number(value) || 0, 0, 1);
      const db = MIN_DB + (MAX_DB - MIN_DB) * v;
      return `${Math.round(db)} dB`;
    };

    const renderModules = (items) => {
      modulesEl.innerHTML = "";
      (items || []).forEach((module) => {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = module.name || module.id;
        btn.addEventListener("click", () => {
          if ((module.id || "").toLowerCase() === "stagepad") {
            modulesView.hidden = true;
            stagepadView.hidden = false;
            document.body.classList.add("in-stagepad");
            setActiveTab("projects");
            send({ type: "list-projects" });
          }
        });
        modulesEl.appendChild(btn);
      });
    };

    const setActiveTab = (name) => {
      tabButtons.forEach((tab) => {
        tab.classList.toggle("is-active", tab.dataset.tab === name);
      });
      panels.forEach((panel) => {
        panel.hidden = panel.dataset.panel !== name;
      });
    };

    tabButtons.forEach((tab) => {
      tab.addEventListener("click", () => {
        setActiveTab(tab.dataset.tab);
      });
    });

    const updateProjectHighlight = () => {
      const activeId = lockedProjectId || activeProjectId;
      projectsEl.querySelectorAll(".btn").forEach((btn) => {
        const id = btn.dataset.projectId;
        const isTop = splitMode && splitTopProjectId && id === splitTopProjectId;
        const isBottom = splitMode && splitBottomProjectId && id === splitBottomProjectId;
        btn.classList.toggle("is-active", splitMode ? isTop || isBottom : id === activeId);
      });
    };

    const renderProjects = (items) => {
      lastProjects = Array.isArray(items) ? items : [];
      projectsEl.innerHTML = "";
      (items || []).forEach((project) => {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = project.name || project.id;
        btn.dataset.projectId = project.id;
        btn.addEventListener("click", () => {
          if (splitMode) {
            if (!splitTopProjectId) {
              splitTopProjectId = project.id;
            } else if (!splitBottomProjectId && project.id !== splitTopProjectId) {
              splitBottomProjectId = project.id;
            } else if (project.id !== splitTopProjectId) {
              splitBottomProjectId = project.id;
            }
            if (!splitTopProjectId) splitTopProjectId = project.id;
            setActiveTab("performance");
            send({ type: "launch-project", projectId: project.id });
            updateProjectHighlight();
            renderPerformanceViews();
          } else {
            activeProjectId = project.id;
            lockedProjectId = project.id;
            stageGridEl.innerHTML = "";
            buttonsHintEl.textContent = "Загружаем кнопки...";
            setActiveTab("performance");
            send({ type: "launch-project", projectId: project.id });
          }
        });
        projectsEl.appendChild(btn);
      });
      updateProjectHighlight();
    };

    const applyGrid = (grid, targetEl, { forceCols = null, forceRows = null } = {}) => {
      const rows = Math.max(1, Number(grid?.rows) || 1);
      const cols = Math.max(1, Number(grid?.cols) || 1);
      const finalRows = forceRows ? Math.max(1, Number(forceRows) || 1) : rows;
      const finalCols = forceCols ? Math.max(1, Number(forceCols) || 1) : cols;
      const el = targetEl || stageGridEl;
      el.style.setProperty("--grid-rows", finalRows);
      el.style.setProperty("--grid-cols", finalCols);
      gridState = { rows: finalRows, cols: finalCols };
      return gridState;
    };

    const buildCellEl = (btnData, projectId, grid) => {
      const cell = document.createElement("div");
      cell.className = "stage-cell";
      if (!btnData) {
        return cell;
      }
      const btn = document.createElement("button");
      btn.className = "stage-cell__btn";
      btn.dataset.buttonId = btnData.id;
      const color = btnData.color || "#00ffa6";
      const alpha = Number.isFinite(btnData.colorAlpha)
        ? Math.max(0, Math.min(1, btnData.colorAlpha))
        : 1;
      const overlay = applyAlphaToHex(color, alpha);
      btn.style.setProperty("--btn-color", color);
      btn.style.border = `1px solid ${color}55`;
      btn.style.boxShadow = `0 0 0 1px ${color}30`;
      btn.style.background = `linear-gradient(145deg, ${overlay}, rgba(0,0,0,0.25))`;
      const label = document.createElement("div");
      label.className = "stage-label";
      label.textContent = btnData.label || "Кнопка";
      btn.appendChild(label);
      const progress = document.createElement("div");
      progress.className = "stage-progress";
      const progressBar = document.createElement("div");
      progressBar.className = "stage-progress__bar";
      progress.appendChild(progressBar);
      btn.appendChild(progress);
      if (btnData.playing) btn.classList.add("stage--playing");
      if (btnData.markUsed && btnData.usedOnce) btn.classList.add("stage--used");
      btn.addEventListener("click", () => {
        send({
          type: "press-button",
          projectId,
          buttonId: btnData.id,
        });
      });
      cell.appendChild(btn);
      return cell;
    };

    const renderButtons = (payload, targetEl, hintEl, options = {}) => {
      const items = payload?.buttons || [];
      const gridEl = targetEl || stageGridEl;
      const hintNode = hintEl || buttonsHintEl;
      gridEl.innerHTML = "";
      if (!items.length) {
        hintNode.textContent = "Нет кнопок в проекте.";
        return;
      }
      hintNode.textContent = "";
      const { forceCols, ignorePositions } = options;
      const forcedRows = forceCols ? Math.ceil(items.length / forceCols) : null;
      const grid = applyGrid(payload?.grid || {}, gridEl, {
        forceCols: forceCols || null,
        forceRows: forcedRows,
      });
      const projectId = payload.projectId || activeProjectId;
      const totalSlots = grid.rows * grid.cols;
      const slots = Array.from({ length: totalSlots }, () => null);
      items.forEach((btnData) => {
        if (ignorePositions) {
          const idx = slots.findIndex((slot) => slot === null);
          if (idx !== -1) slots[idx] = btnData;
          return;
        }
        if (typeof btnData.position === "number" && btnData.position >= 0 && btnData.position < totalSlots) {
          slots[btnData.position] = btnData;
        }
      });
      slots.forEach((btnData) => {
        const cell = buildCellEl(btnData, projectId, grid);
        gridEl.appendChild(cell);
      });
    };

    const renderMixer = (payload) => {
      if (mixerDragging) return;
      let usedGroups = Array.isArray(payload?.usedGroups) ? payload.usedGroups : [];
      let activeGroups = Array.isArray(payload?.activeGroups) ? payload.activeGroups : [];
      const mixerGroups = Array.isArray(payload?.mixerGroups) ? payload.mixerGroups : [];
      const mixerSliders = Array.isArray(payload?.mixerSliders) ? payload.mixerSliders : [];
      const groupNames = Array.isArray(payload?.groupNames) ? payload.groupNames : [];
      if (splitMode) {
        const unionUsed = new Set();
        const unionActive = new Set();
        const topState = splitTopProjectId ? perfStates.get(splitTopProjectId) : null;
        const bottomState = splitBottomProjectId ? perfStates.get(splitBottomProjectId) : null;
        [topState, bottomState].forEach((statePayload) => {
          const groups = Array.isArray(statePayload?.usedGroups) ? statePayload.usedGroups : [];
          groups.forEach((g) => unionUsed.add(Number(g)));
          const active = Array.isArray(statePayload?.activeGroups) ? statePayload.activeGroups : [];
          active.forEach((g) => unionActive.add(Number(g)));
        });
        usedGroups = Array.from(unionUsed).filter((g) => Number.isFinite(g));
        activeGroups = Array.from(unionActive).filter((g) => Number.isFinite(g));
      }
      mixerListEl.innerHTML = "";
      if (!usedGroups.length || !mixerGroups.length) {
        mixerHintEl.textContent = "Нет активных фейдеров.";
        return;
      }
      mixerHintEl.textContent = "";
      usedGroups
        .sort((a, b) => a - b)
        .forEach((index) => {
          const name = groupNames[index] || (index >= 8 ? `FX ${index - 7}` : `Bus ${index + 1}`);
          const value = Math.max(0, Math.min(1, Number(mixerGroups[index] ?? 1)));
          const sliderPosRaw = Number(mixerSliders[index]);
          const sliderPos = Number.isFinite(sliderPosRaw)
            ? clamp(sliderPosRaw, 0, 1)
            : gainToSlider(value);
          const item = document.createElement("div");
          item.className = "mixer-item";
          const titleRow = document.createElement("div");
          titleRow.className = "mixer-title";
          const dot = document.createElement("span");
          dot.className = "mixer-dot";
          if (activeGroups.includes(index)) dot.classList.add("is-active");
          const title = document.createElement("h4");
          title.textContent = name;
          titleRow.appendChild(dot);
          titleRow.appendChild(title);
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = "0";
          slider.max = "1";
          slider.step = "0.01";
          slider.value = sliderPos.toFixed(2);
          slider.style.touchAction = "none";
          const valueEl = document.createElement("div");
          valueEl.className = "mixer-value";
          valueEl.textContent = formatDb(slider.value);
          let sendFrame = null;
          let lastSent = null;
          const sendNow = () => {
            const nextValue = sliderToGain(slider.value);
            if (lastSent !== null && Math.abs(nextValue - lastSent) < 0.0005) return;
            lastSent = nextValue;
            send({
              type: "set-mixer-group",
              index,
              value: nextValue,
              projectId: lockedProjectId || activeProjectId,
            });
          };
          const scheduleSend = () => {
            if (sendFrame) return;
            sendFrame = requestAnimationFrame(() => {
              sendFrame = null;
              sendNow();
            });
          };
          const updateFromClientX = (clientX) => {
            const rect = slider.getBoundingClientRect();
            const ratio = rect.width > 0 ? (clientX - rect.left) / rect.width : 0;
            const nextValue = Math.max(0, Math.min(1, ratio));
            slider.value = nextValue.toFixed(2);
            valueEl.textContent = formatDb(slider.value);
            scheduleSend();
          };
          let dragging = false;
          slider.addEventListener("pointerdown", (event) => {
            dragging = true;
            mixerDragging = true;
            mixerDraggingIndex = index;
            slider.setPointerCapture?.(event.pointerId);
            updateFromClientX(event.clientX);
            sendNow();
          });
          slider.addEventListener("pointermove", (event) => {
            if (!dragging) return;
            updateFromClientX(event.clientX);
          });
          const stopDrag = (event) => {
            if (!dragging) return;
            dragging = false;
            mixerDragging = false;
            mixerDraggingIndex = null;
            slider.releasePointerCapture?.(event.pointerId);
            sendNow();
            if (lastPerfState) {
              renderMixer(lastPerfState);
            }
          };
          slider.addEventListener("pointerup", stopDrag);
          slider.addEventListener("pointercancel", stopDrag);
          slider.addEventListener("touchstart", (event) => {
            if (event.touches && event.touches[0]) {
              mixerDragging = true;
              mixerDraggingIndex = index;
              updateFromClientX(event.touches[0].clientX);
              sendNow();
            }
          }, { passive: true });
          slider.addEventListener("touchmove", (event) => {
            if (event.touches && event.touches[0]) {
              updateFromClientX(event.touches[0].clientX);
            }
          }, { passive: true });
          slider.addEventListener("touchend", () => {
            mixerDragging = false;
            mixerDraggingIndex = null;
            sendNow();
            if (lastPerfState) {
              renderMixer(lastPerfState);
            }
          });
          slider.addEventListener("input", () => {
            valueEl.textContent = formatDb(slider.value);
            scheduleSend();
          });
          slider.addEventListener("change", () => {
            sendNow();
          });
          item.appendChild(titleRow);
          item.appendChild(slider);
          item.appendChild(valueEl);
          mixerListEl.appendChild(item);
        });
    };

    const updateButtonState = (payload, targetEl) => {
      const items = payload?.buttons || [];
      const projectId = payload?.projectId || "";
      if (!splitMode && lockedProjectId && projectId && lockedProjectId !== projectId) {
        return;
      }
      if (!items.length) return;
      const gridEl = targetEl || stageGridEl;
      const grid = applyGrid(payload?.grid || {}, gridEl);
      const byId = new Map(items.map((item) => [item.id, item]));
      const existing = gridEl.querySelectorAll(".stage-cell__btn");
      if (existing.length === 0 || gridEl.children.length !== grid.rows * grid.cols) {
        renderButtons(payload, gridEl, gridEl === stageGridBottomEl ? buttonsHintBottomEl : buttonsHintEl);
        return;
      }
      existing.forEach((btn) => {
        const id = btn.dataset.buttonId;
        if (!id || !byId.has(id)) return;
        const data = byId.get(id);
        btn.classList.toggle("stage--playing", Boolean(data.playing));
        btn.classList.toggle("stage--used", Boolean(data.markUsed && data.usedOnce));
        const progressEl = btn.querySelector(".stage-progress__bar");
        if (progressEl) {
          const progress = Math.max(0, Math.min(1, Number(data.progress) || 0));
          progressEl.style.width = `${progress * 100}%`;
        }
      });
    };

    const updateButtonStateSimple = (payload, targetEl) => {
      const items = payload?.buttons || [];
      const projectId = payload?.projectId || "";
      if (!splitMode && lockedProjectId && projectId && lockedProjectId !== projectId) {
        return;
      }
      if (!items.length) return;
      const gridEl = targetEl || stageGridEl;
      const byId = new Map(items.map((item) => [item.id, item]));
      const existing = gridEl.querySelectorAll(".stage-cell__btn");
      if (existing.length === 0) return;
      existing.forEach((btn) => {
        const id = btn.dataset.buttonId;
        if (!id || !byId.has(id)) return;
        const data = byId.get(id);
        btn.classList.toggle("stage--playing", Boolean(data.playing));
        btn.classList.toggle("stage--used", Boolean(data.markUsed && data.usedOnce));
        const progressEl = btn.querySelector(".stage-progress__bar");
        if (progressEl) {
          const progress = Math.max(0, Math.min(1, Number(data.progress) || 0));
          progressEl.style.width = `${progress * 100}%`;
        }
      });
    };

    const needsRenderButtons = (payload, targetEl, options = {}) => {
      const items = payload?.buttons || [];
      const gridEl = targetEl || stageGridEl;
      if (!items.length) {
        return gridEl.children.length > 0;
      }
      const { forceCols } = options;
      let rows = Math.max(1, Number(payload?.grid?.rows) || 1);
      let cols = Math.max(1, Number(payload?.grid?.cols) || 1);
      if (forceCols) {
        cols = Math.max(1, Number(forceCols) || 1);
        rows = Math.max(1, Math.ceil(items.length / cols));
      }
      const totalSlots = rows * cols;
      if (gridEl.children.length !== totalSlots) return true;
      const existingIds = new Set(
        Array.from(gridEl.querySelectorAll(".stage-cell__btn")).map((btn) => btn.dataset.buttonId)
      );
      for (const item of items) {
        if (!existingIds.has(item.id)) return true;
      }
      return false;
    };

    const renderOrUpdateButtons = (payload, targetEl, hintEl, options = {}) => {
      if (options.forceCols || options.ignorePositions) {
        renderButtons(payload, targetEl, hintEl, options);
        return;
      }
      if (needsRenderButtons(payload, targetEl, options)) {
        renderButtons(payload, targetEl, hintEl, options);
        return;
      }
      updateButtonStateSimple(payload, targetEl);
    };

    const setSplitMode = (enabled) => {
      splitMode = Boolean(enabled);
      document.body.classList.toggle("split-mode", splitMode);
      if (splitToggleBtn) {
        splitToggleBtn.textContent = splitMode ? "Сплит: вкл" : "Сплит: выкл";
      }
      if (splitMode) {
        splitBottomEl.hidden = false;
        if (!splitTopProjectId) {
          const fallback = lockedProjectId || activeProjectId || lastProjects[0]?.id || "";
          splitTopProjectId = fallback;
          if (splitTopProjectId) {
            send({ type: "launch-project", projectId: splitTopProjectId });
          }
        }
      } else {
        splitBottomEl.hidden = true;
        splitBottomProjectId = "";
        if (splitTopProjectId) {
          lockedProjectId = splitTopProjectId;
        }
        splitTopProjectId = "";
      }
      updateProjectHighlight();
      renderPerformanceViews();
    };

    const renderPerformanceViews = () => {
      if (!splitMode) {
        const projectId = lockedProjectId || activeProjectId;
        if (projectId && perfStates.has(projectId)) {
          renderOrUpdateButtons(perfStates.get(projectId), stageGridEl, buttonsHintEl);
        }
        if (splitBottomEl) splitBottomEl.hidden = true;
        return;
      }
      if (splitBottomEl) splitBottomEl.hidden = false;
      if (splitTopProjectId && perfStates.has(splitTopProjectId)) {
        renderOrUpdateButtons(perfStates.get(splitTopProjectId), stageGridEl, buttonsHintEl, {
          forceCols: 4,
          ignorePositions: true,
        });
      }
      if (splitBottomProjectId && perfStates.has(splitBottomProjectId)) {
        renderOrUpdateButtons(perfStates.get(splitBottomProjectId), stageGridBottomEl, buttonsHintBottomEl);
      } else {
        stageGridBottomEl.innerHTML = "";
        buttonsHintBottomEl.textContent = "Выберите второй проект для сплита.";
      }
    };

    if (resetUsedBtn) {
      resetUsedBtn.addEventListener("click", () => {
        const projectId = splitMode ? splitBottomProjectId || splitTopProjectId : (lockedProjectId || activeProjectId);
        if (!projectId) return;
        send({
          type: "reset-used",
          projectId,
        });
      });
    }

    if (splitToggleBtn) {
      splitToggleBtn.addEventListener("click", () => {
        setSplitMode(!splitMode);
      });
    }

    const connect = () => {
      const protocol = location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = `${protocol}://${location.host}`;
      ws = new WebSocket(wsUrl);
      showStatus("Подключаемся...", "");

      ws.addEventListener("open", () => {
        showStatus("Подключено", "", { autoHide: true });
        send({ type: "get-modules" });
      });
      ws.addEventListener("close", () => {
        showStatus("Соединение закрыто", "Переподключение...");
        setTimeout(connect, 1500);
      });
      ws.addEventListener("error", () => {
        showStatus("Ошибка соединения", "Проверьте, что сервер запущен.");
      });
      ws.addEventListener("message", (event) => {
        let payload = null;
        try {
          payload = JSON.parse(event.data);
        } catch {
          return;
        }
        if (payload.type === "modules") {
          renderModules(payload.items);
        } else if (payload.type === "projects") {
          renderProjects(payload.items);
        } else if (payload.type === "performance-buttons") {
          const projectId = payload.projectId || "";
          if (projectId) {
            perfStates.set(projectId, payload);
          }
          if (!splitMode) {
            activeProjectId = projectId || activeProjectId;
            if (!lockedProjectId) lockedProjectId = activeProjectId;
          }
          lastPerfState = payload;
          renderPerformanceViews();
          renderMixer(payload);
          updateProjectHighlight();
        } else if (payload.type === "performance-state") {
          const statePayload = payload.payload || {};
          const nextProjectId = statePayload.projectId || "";
          if (nextProjectId) {
            perfStates.set(nextProjectId, statePayload);
          }
          if (!splitMode) {
            if (lockedProjectId && nextProjectId && lockedProjectId !== nextProjectId) {
              return;
            }
            activeProjectId = nextProjectId || activeProjectId;
          }
          lastPerfState = statePayload;
          renderPerformanceViews();
          renderMixer(statePayload);
          updateProjectHighlight();
        } else if (payload.type === "error") {
          hintEl.textContent = payload.message || "Ошибка";
        }
      });
    };

    connect();
  </script>
</body>
</html>
