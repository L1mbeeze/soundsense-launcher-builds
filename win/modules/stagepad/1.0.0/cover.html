<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>StagePad Cover</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      color: #0fffa6;
      font-family: "Segoe UI", sans-serif;
      user-select: none;
      overflow: hidden;
    }
    body {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      aspect-ratio: var(--stagepad-cover-aspect, 16 / 9);
      margin: auto;
    }
    .placeholder {
      opacity: 0.35;
      letter-spacing: 2px;
      font-size: 24px;
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
    }
    .layer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      user-select: none;
      pointer-events: none;
    }
    .layer svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    .text-effect-shadow-dance {
      display: inline-block;
      white-space: pre;
      --shadow-a: #ff005e;
      --shadow-b: #00d4ff;
      --effect-speed: 2s;
      animation: shadow-dance var(--effect-speed) infinite;
    }
    .text-effect-melting {
      display: inline-block;
      white-space: pre;
      font-weight: 700;
      text-transform: uppercase;
      --melt-a: #ff6f61;
      --melt-b: #ffbd44;
      --effect-speed: 3s;
      background: linear-gradient(90deg, var(--melt-a), var(--melt-b), var(--melt-a));
      -webkit-background-clip: text;
      color: transparent;
      position: relative;
      animation: melt var(--effect-speed) infinite ease-in-out;
    }
    .text-effect-melting::before,
    .text-effect-melting::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, var(--melt-a), var(--melt-b), var(--melt-a));
      -webkit-background-clip: text;
      color: transparent;
      z-index: -1;
      transform: scaleY(1);
      opacity: 0.5;
      animation: drip var(--effect-speed) infinite ease-in-out;
    }
    .text-effect-melting::after {
      filter: blur(10px);
      opacity: 0.3;
    }
    .text-effect-matrix {
      display: inline-block;
      position: relative;
      white-space: pre;
      --matrix-color: #00ff66;
      --matrix-glow: #00ff66;
      --matrix-rain: rgba(0, 255, 0, 0.2);
      --effect-speed: 2s;
      --rain-speed: 10s;
      color: var(--matrix-color);
      text-shadow: 0 0 10px var(--matrix-glow), 0 0 20px var(--matrix-glow), 0 0 30px var(--matrix-glow);
      font-family: "Consolas", "Courier New", monospace;
    }
    .text-effect-matrix::before {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      animation: glitch var(--effect-speed) infinite;
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
      transform: translate(-2px, -2px);
      color: var(--matrix-color);
      text-shadow: 0 0 5px var(--matrix-glow), 0 0 15px var(--matrix-glow);
    }

    .text-effect-masked {
      display: inline-block;
      white-space: pre;
      font-weight: 700;
      text-transform: uppercase;
      --mask-image: url("image.avif");
      --mask-a: #ff6f61;
      --mask-b: #ffbd44;
      --effect-speed: 5s;
      background-image: var(--mask-image, linear-gradient(90deg, var(--mask-a), var(--mask-b), var(--mask-a)));
      background-size: 200%;
      background-position: 0 50%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: animate-background var(--effect-speed) infinite alternate linear;
    }
    .text-effect-spin {
      display: inline-block;
      white-space: pre;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--spin-base, #ffffff);
      text-shadow:
        1px 1px 0 var(--spin-1, #e63946),
        2px 2px 0 var(--spin-2, #f77f00),
        3px 3px 0 var(--spin-3, #fcbf49),
        4px 4px 0 var(--spin-4, #a8dadc),
        5px 5px 0 var(--spin-5, #457b9d);
      transform-style: preserve-3d;
      animation: spin-3d var(--effect-speed, 4s) infinite linear;
    }
    .text-effect-neon {
      display: inline-block;
      white-space: pre;
      color: var(--neon-base, #ffffff);
      --neon-a: #ff005e;
      --neon-b: #00d4ff;
      --effect-speed: 1.5s;
      text-shadow:
        0 0 5px var(--neon-a),
        0 0 10px var(--neon-a),
        0 0 20px var(--neon-a),
        0 0 40px var(--neon-a),
        0 0 80px var(--neon-a);
      animation: glow var(--effect-speed) infinite alternate;
    }
    .text-effect-follow {
      display: inline-block;
      white-space: pre;
      color: var(--follow-base, #ffffff);
      --follow-a: #e30613;
      --follow-b: #009fe3;
      --follow-c: #ffed00;
      --follow-x1: 0px;
      --follow-y1: 0px;
      --follow-x2: 0px;
      --follow-y2: 0px;
      --follow-x3: 0px;
      --follow-y3: 0px;
      text-shadow:
        var(--follow-y1) var(--follow-x1) var(--follow-a),
        var(--follow-y2) var(--follow-x2) var(--follow-c),
        var(--follow-x3) var(--follow-y3) var(--follow-b);
    }
    .matrix-rain {
      position: absolute;
      inset: -200% 0 0 0;
      background: repeating-linear-gradient(
        0deg,
        var(--matrix-rain) 0,
        var(--matrix-rain) 2px,
        transparent 4px
      );
      animation: rain var(--rain-speed) linear infinite;
      z-index: -1;
      pointer-events: none;
    }
    @keyframes shadow-dance {
      0%, 100% {
        text-shadow: 5px 5px 0 #ff005e, 10px 10px 0 #00d4ff;
      }
      50% {
        text-shadow: -5px -5px 0 #00d4ff, -10px -10px 0 #ff005e;
      }
    }
    @keyframes melt {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(20px);
      }
    }
    @keyframes drip {
      0%, 100% {
        transform: scaleY(1);
        opacity: 0.5;
      }
      50% {
        transform: scaleY(1.5);
        opacity: 0.7;
      }
    }
    @keyframes rain {
      0% {
        transform: translateY(-50%);
      }
      100% {
        transform: translateY(50%);
      }
    }
    @keyframes glitch {
      0%, 100% {
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        transform: translate(0);
      }
      33% {
        clip-path: polygon(0 0, 100% 0, 100% 15%, 0 15%);
        transform: translate(-5px, -5px);
      }
      66% {
        clip-path: polygon(0 85%, 100% 85%, 100% 100%, 0 100%);
        transform: translate(5px, 5px);
      }
    }
    @keyframes animate-background {
      0% {
        background-position: 0 50%;
      }
      100% {
        background-position: 100% 50%;
      }
    }
    @keyframes spin-3d {
      0% {
        transform: rotateY(0deg);
      }
      100% {
        transform: rotateY(360deg);
      }
    }
    @keyframes glow {
      0% {
        text-shadow:
          0 0 5px var(--neon-a),
          0 0 10px var(--neon-a),
          0 0 20px var(--neon-a),
          0 0 40px var(--neon-a),
          0 0 80px var(--neon-a);
      }
      100% {
        text-shadow:
          0 0 10px var(--neon-b),
          0 0 20px var(--neon-b),
          0 0 40px var(--neon-b),
          0 0 80px var(--neon-b),
          0 0 160px var(--neon-b);
      }
    }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="placeholder" id="placeholder">Обложка</div>
  </div>
  <script>
    const stage = document.getElementById("stage");
    const placeholder = document.getElementById("placeholder");
    const params = new URLSearchParams(window.location.search);
    const logoUrl = params.get("logo");
    const baseUrl = params.get("base");
    const COVER_FORMAT_KEY = "stagepadCoverFormat";
    const COVER_FORMATS = {
      "16:9": { css: "16 / 9", ratio: 16 / 9 },
      "4:3": { css: "4 / 3", ratio: 4 / 3 },
      "1:1": { css: "1 / 1", ratio: 1 },
      "9:16": { css: "9 / 16", ratio: 9 / 16 },
    };
    let coverData = null;
    let currentFormat = null;

    const getTextMetrics = (layer) => {
      const text = layer.text ?? "Текст";
      const size = Number(layer.fontSize || 72);
      const family = layer.fontFamily || "Segoe UI";
      const italic = layer.italic ? "italic " : "";
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return { width: size * text.length * 0.6, height: size * 1.2 };
      }
      ctx.font = `${italic}${size}px ${family}`;
      const width = ctx.measureText(text).width;
      const curveBoost = Math.abs(layer.curve || 0) * 0.6;
      return { width: Math.max(1, width), height: Math.max(1, size * 1.2 + curveBoost) };
    };

    const resolveAssetUrl = (assetPath) => {
      if (!assetPath) return "";
      if (assetPath.startsWith("file:") || assetPath.startsWith("data:")) return assetPath;
      if (!baseUrl) return assetPath;
      return new URL(assetPath, baseUrl).toString();
    };

    const renderTextLayer = (layer) => {
      const metrics = getTextMetrics(layer);
      const width = layer.baseSize?.width || metrics.width;
      const height = layer.baseSize?.height || metrics.height;
      const wrap = document.createElement("div");
      wrap.className = "layer";
      wrap.style.width = `${width}px`;
      wrap.style.height = `${height}px`;

      const effect = layer.effect || "none";
      const effectSettings = layer.effectSettings || {};
      const curve = Number(layer.curve || 0);
      const textValue = layer.text ?? "Текст";
      if (effect === "shadow-dance" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-shadow-dance";
        span.textContent = textValue;
        span.style.setProperty("--shadow-a", effectSettings.colorA || "#ff005e");
        span.style.setProperty("--shadow-b", effectSettings.colorB || "#00d4ff");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 2}s`);
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        span.style.color = layer.color || "#ffffff";
        const strokeWidth = Number(layer.strokeWidth || 0);
        if (strokeWidth > 0) {
          span.style.webkitTextStroke = `${strokeWidth}px ${layer.strokeColor || "#000000"}`;
        } else {
          span.style.webkitTextStroke = "0px transparent";
        }
        wrap.append(span);
      } else if (effect === "melting" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-melting";
        span.textContent = textValue;
        span.dataset.text = textValue;
        span.style.setProperty("--melt-a", effectSettings.colorA || "#ff6f61");
        span.style.setProperty("--melt-b", effectSettings.colorB || "#ffbd44");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 3}s`);
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        wrap.append(span);
      } else if (effect === "matrix" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-matrix";
        span.textContent = textValue;
        span.dataset.text = textValue;
        span.style.setProperty("--matrix-color", effectSettings.colorA || "#00ff66");
        span.style.setProperty("--matrix-glow", effectSettings.colorB || effectSettings.colorA || "#00ff66");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 2}s`);
        span.style.setProperty("--rain-speed", `${effectSettings.rainSpeed || 10}s`);
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        const rain = document.createElement("span");
        rain.className = "matrix-rain";
        const rainOpacity = typeof effectSettings.rainOpacity === "number" ? effectSettings.rainOpacity : 0.2;
        const baseColor = effectSettings.colorA || "#00ff66";
        const hex = baseColor.replace("#", "");
        const value = hex.length === 3 ? hex.split("").map((c) => c + c).join("") : hex;
        const rgb =
          /^[0-9a-fA-F]{6}$/.test(value)
            ? {
                r: parseInt(value.slice(0, 2), 16),
                g: parseInt(value.slice(2, 4), 16),
                b: parseInt(value.slice(4, 6), 16),
              }
            : { r: 0, g: 255, b: 0 };
        rain.style.setProperty("--matrix-rain", `rgba(${rgb.r},${rgb.g},${rgb.b},${rainOpacity})`);
        span.append(rain);
        wrap.append(span);
      } else if (effect === "masked" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-masked";
        span.textContent = textValue;
        span.style.setProperty("--mask-a", effectSettings.colorA || "#ff6f61");
        span.style.setProperty("--mask-b", effectSettings.colorB || "#ffbd44");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 5}s`);
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        wrap.append(span);
      } else if (effect === "spin-3d" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-spin";
        span.textContent = textValue;
        span.style.setProperty("--spin-base", layer.color || "#ffffff");
        span.style.setProperty("--spin-1", effectSettings.colorA || "#e63946");
        span.style.setProperty("--spin-2", "#f77f00");
        span.style.setProperty("--spin-3", "#fcbf49");
        span.style.setProperty("--spin-4", "#a8dadc");
        span.style.setProperty("--spin-5", effectSettings.colorB || "#457b9d");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 4}s`);
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        const strokeWidth = Number(layer.strokeWidth || 0);
        if (strokeWidth > 0) {
          span.style.webkitTextStroke = `${strokeWidth}px ${layer.strokeColor || "#000000"}`;
        } else {
          span.style.webkitTextStroke = "0px transparent";
        }
        wrap.append(span);
      } else if (effect === "neon" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-neon";
        span.textContent = textValue;
        span.style.setProperty("--neon-base", layer.color || "#ffffff");
        span.style.setProperty("--neon-a", effectSettings.colorA || "#ff005e");
        span.style.setProperty("--neon-b", effectSettings.colorB || "#00d4ff");
        span.style.setProperty("--effect-speed", `${effectSettings.speed || 1.5}s`);
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        const strokeWidth = Number(layer.strokeWidth || 0);
        if (strokeWidth > 0) {
          span.style.webkitTextStroke = `${strokeWidth}px ${layer.strokeColor || "#000000"}`;
        } else {
          span.style.webkitTextStroke = "0px transparent";
        }
        wrap.append(span);
      } else if (effect === "shadow-follow" && curve === 0) {
        const span = document.createElement("span");
        span.className = "text-effect-follow";
        span.textContent = textValue;
        span.style.setProperty("--follow-base", layer.color || "#ffffff");
        span.style.setProperty("--follow-a", effectSettings.colorA || "#e30613");
        span.style.setProperty("--follow-b", effectSettings.colorB || "#009fe3");
        span.style.setProperty("--follow-c", effectSettings.colorC || "#ffed00");
        span.style.fontFamily = layer.fontFamily || "Segoe UI";
        span.style.fontSize = `${layer.fontSize || 72}px`;
        span.style.fontStyle = layer.italic ? "italic" : "normal";
        const strokeWidth = Number(layer.strokeWidth || 0);
        if (strokeWidth > 0) {
          span.style.webkitTextStroke = `${strokeWidth}px ${layer.strokeColor || "#000000"}`;
        } else {
          span.style.webkitTextStroke = "0px transparent";
        }
        wrap.append(span);
      } else {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${metrics.width} ${metrics.height}`);
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const pathId = `cover_text_${layer.id}`;
        const midY = metrics.height / 2;
        const controlY = midY - curve;
        path.setAttribute("id", pathId);
        path.setAttribute("d", `M 0 ${midY} Q ${metrics.width / 2} ${controlY} ${metrics.width} ${midY}`);
        defs.append(path);
        svg.append(defs);
        const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textEl.setAttribute("text-anchor", "middle");
        textEl.setAttribute("dominant-baseline", "middle");
        textEl.setAttribute("fill", layer.color || "#ffffff");
        const strokeWidth = Number(layer.strokeWidth || 0);
        if (strokeWidth > 0) {
          textEl.setAttribute("stroke", layer.strokeColor || "#000000");
          textEl.setAttribute("stroke-width", String(strokeWidth));
          textEl.setAttribute("paint-order", "stroke");
          textEl.setAttribute("stroke-linejoin", "round");
        }
        textEl.setAttribute("font-family", layer.fontFamily || "Segoe UI");
        textEl.setAttribute("font-size", String(layer.fontSize || 72));
        textEl.setAttribute("font-style", layer.italic ? "italic" : "normal");
        if (curve !== 0) {
          const textPath = document.createElementNS("http://www.w3.org/2000/svg", "textPath");
          textPath.setAttribute("href", `#${pathId}`);
          textPath.setAttribute("startOffset", "50%");
          textPath.setAttribute("text-anchor", "middle");
          textPath.textContent = textValue;
          textEl.append(textPath);
        } else {
          textEl.setAttribute("x", String(metrics.width / 2));
          textEl.setAttribute("y", String(midY));
          textEl.textContent = textValue;
        }
        svg.append(textEl);
        wrap.append(svg);
      }
      return wrap;
    };

    const renderImageLayer = (layer) => {
      const img = document.createElement("img");
      img.className = "layer";
      const src = resolveAssetUrl(layer.assetPath || layer.src || "");
      if (!src) return null;
      img.src = src;
      if (layer.baseSize?.width && layer.baseSize?.height) {
        img.style.width = `${layer.baseSize.width}px`;
        img.style.height = `${layer.baseSize.height}px`;
      }
      return img;
    };

    const renderLogo = (data) => {
      if (!data || !Array.isArray(data.layers) || !data.layers.length) return;
      placeholder.hidden = true;
      stage.querySelectorAll(".layer").forEach((node) => node.remove());
      const stageRect = stage.getBoundingClientRect();
      const workspace = data.workspace || { width: stageRect.width, height: stageRect.height };
      const scaleW = workspace.width ? stageRect.width / workspace.width : 1;
      const scaleH = workspace.height ? stageRect.height / workspace.height : scaleW;
      const scale = Math.min(scaleW, scaleH);
      data.layers.forEach((layer) => {
        let el = null;
        if (layer.type === "text") {
          el = renderTextLayer(layer);
        } else {
          el = renderImageLayer(layer);
        }
        if (!el) return;
        const offsetX = (layer.offset?.x || 0) * scale;
        const offsetY = (layer.offset?.y || 0) * scale;
        const layerScale = layer.scale ?? 1;
        el.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${layerScale * scale})`;
        stage.append(el);
      });
    };

    const loadFonts = async (fonts) => {
      if (!Array.isArray(fonts) || !fonts.length) return;
      const loads = fonts.map((font) => {
        if (!font?.family || !font?.assetPath) return null;
        const url = resolveAssetUrl(font.assetPath);
        if (!url) return null;
        try {
          const face = new FontFace(font.family, `url("${url}")`);
          document.fonts.add(face);
          return face.load().catch(() => null);
        } catch (_) {
          return null;
        }
      });
      await Promise.all(loads.filter(Boolean));
      try {
        await document.fonts.ready;
      } catch (_) {
        /* ignore */
      }
    };

    const getFormat = () => {
      const value = localStorage.getItem(COVER_FORMAT_KEY);
      return COVER_FORMATS[value] ? value : "16:9";
    };

    const applyStageSize = () => {
      const format = getFormat();
      if (currentFormat !== format) {
        currentFormat = format;
        const css = COVER_FORMATS[format]?.css || "16 / 9";
        document.documentElement.style.setProperty("--stagepad-cover-aspect", css);
      }
      const ratio = COVER_FORMATS[currentFormat]?.ratio || 16 / 9;
      const vw = window.innerWidth || 1;
      const vh = window.innerHeight || 1;
      let width = vw;
      let height = Math.round(width / ratio);
      if (height > vh) {
        height = vh;
        width = Math.round(height * ratio);
      }
      stage.style.width = `${width}px`;
      stage.style.height = `${height}px`;
    };

    const applyFormatAndRender = () => {
      applyStageSize();
      if (coverData) {
        requestAnimationFrame(() => renderLogo(coverData));
      }
    };

    if (logoUrl) {
      fetch(logoUrl)
        .then((res) => res.json())
        .then(async (data) => {
          coverData = data;
          await loadFonts(data?.fonts);
          applyFormatAndRender();
        })
        .catch(() => {});
    }

    window.addEventListener("resize", () => {
      applyFormatAndRender();
    });

    window.addEventListener("storage", (event) => {
      if (event.key === COVER_FORMAT_KEY) {
        applyFormatAndRender();
      }
    });

    applyFormatAndRender();
  </script>
</body>
</html>
